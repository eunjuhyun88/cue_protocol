// ============================================================================
// üóÑÔ∏è ÌÜµÌï©Îêú ÏôÑÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ ÎùºÏö∞Ìä∏ ÏãúÏä§ÌÖú
// ÌååÏùº: backend/src/routes/vault/index.ts
// Í∏∞Ï°¥ Í∏∞Îä• + Ïã†Í∑ú Í∏∞Îä• = ÏôÑÏ†ÑÌïú Î≥ºÌä∏ ÏãúÏä§ÌÖú
// ============================================================================

import { Router, Request, Response } from 'express';
import { DatabaseService } from '../../services/database/DatabaseService';
import { SupabaseService } from '../../services/database/SupabaseService';
import { SemanticCompressionService } from '../../services/ai/SemanticCompressionService';
import { PersonalCueExtractor } from '../../services/ai/PersonalCueExtractor';
import { CUEMiningService } from '../../services/cue/CUEMiningService';
import { CryptoService } from '../../services/encryption/CryptoService';
import { authMiddleware } from '../../middleware/authMiddleware';
import { asyncHandler } from '../../middleware/errorHandler';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

// ÏÑúÎπÑÏä§ Ïù∏Ïä§ÌÑ¥Ïä§Îì§ (Í∏∞Ï°¥ + Ïã†Í∑ú ÌÜµÌï©)
const databaseService = DatabaseService.getInstance();
const supabaseService = SupabaseService.getInstance();
const compressionService = new SemanticCompressionService();
const cueExtractor = new PersonalCueExtractor();
const cueMinigService = new CUEMiningService();
const cryptoService = CryptoService.getInstance();

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑúÎπÑÏä§ ÏÑ†ÌÉù (ÌôòÍ≤ΩÏóê Îî∞Îùº)
const db = process.env.USE_MOCK_DATABASE === 'true' || 
          !process.env.SUPABASE_URL || 
          process.env.SUPABASE_URL.includes('dummy')
  ? databaseService
  : supabaseService;

console.log('üóÑÔ∏è ÌÜµÌï© Vault routes initialized with:', db.constructor.name);

// ============================================================================
// üóÑÔ∏è Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ Î™©Î°ù Ï°∞Ìöå (Í∏∞Ï°¥ + Ïã†Í∑ú Í∏∞Îä• ÌÜµÌï©)
// GET /api/vault ÎòêÎäî GET /api/vault/:did
// ============================================================================

router.get('/', authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const user = (req as any).user;
  const { category, encrypted, limit = 50, offset = 0 } = req.query;

  try {
    console.log(`üóÑÔ∏è Î≥ºÌä∏ Î™©Î°ù Ï°∞Ìöå - ÏÇ¨Ïö©Ïûê: ${user.id || user.did}`);

    // Îëê Í∞ÄÏßÄ Î∞©Ïãù Î™®Îëê ÏßÄÏõê (Í∏∞Ï°¥ getUserVaults + Ïã†Í∑ú getDataVaults)
    let vaults;
    if (typeof db.getUserVaults === 'function') {
      vaults = await db.getUserVaults(user.id);
    } else {
      vaults = await db.getDataVaults(user.did);
    }

    // ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö© (Ïã†Í∑ú Í∏∞Îä•)
    if (category) {
      vaults = vaults.filter(vault => 
        (vault.vault_type || vault.category) === category
      );
    }
    
    if (encrypted !== undefined) {
      const isEncrypted = encrypted === 'true';
      vaults = vaults.filter(vault => 
        (vault.is_encrypted || vault.encrypted) === isEncrypted
      );
    }

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ï†ÅÏö©
    const limitNum = parseInt(limit as string);
    const offsetNum = parseInt(offset as string);
    const paginatedVaults = vaults.slice(offsetNum, offsetNum + limitNum);

    // ÌÜµÍ≥Ñ Í≥ÑÏÇ∞ (Ïã†Í∑ú Í∏∞Îä•)
    const vaultStats = {
      total: vaults.length,
      categories: [...new Set(vaults.map(v => v.vault_type || v.category))],
      totalSize: vaults.reduce((sum, v) => sum + (v.total_size || v.dataSize || 0), 0),
      encryptedCount: vaults.filter(v => v.is_encrypted || v.encrypted).length
    };

    // ÏùëÎãµ ÌòïÏãù ÌÜµÌï©
    const responseVaults = paginatedVaults.map(vault => ({
      id: vault.id,
      name: vault.vault_name || vault.name,
      description: vault.description,
      type: vault.vault_type || vault.category,
      isEncrypted: vault.is_encrypted || vault.encrypted,
      compartmentCount: vault.compartment_count || 0,
      totalSize: vault.total_size || vault.dataSize || 0,
      createdAt: vault.created_at || vault.createdAt,
      lastAccessed: vault.last_accessed_at || vault.updatedAt,
      permissions: vault.access_permissions,
      compressed: vault.compressed,
      tags: vault.tags || []
    }));

    res.json({
      success: true,
      vaults: responseVaults,
      stats: vaultStats,
      pagination: {
        limit: limitNum,
        offset: offsetNum,
        total: vaults.length,
        hasMore: offsetNum + limitNum < vaults.length
      },
      count: responseVaults.length,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Î≥ºÌä∏ Î™©Î°ù Ï°∞Ìöå Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get vaults',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üì¶ ÏÉà Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ ÏÉùÏÑ± (Í∏∞Ï°¥ + Ïã†Í∑ú Í∏∞Îä• ÌÜµÌï©)
// POST /api/vault ÎòêÎäî POST /api/vault/:did
// ============================================================================

router.post(['/', '/:did'], authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const { name, description, type = 'personal', isEncrypted = true, category } = req.body;
  const user = (req as any).user;
  const did = req.params.did || user.did;

  if (!name?.trim()) {
    return res.status(400).json({
      success: false,
      error: 'Vault name is required'
    });
  }

  try {
    console.log(`üì¶ ÏÉà Î≥ºÌä∏ ÏÉùÏÑ± - ÏÇ¨Ïö©Ïûê: ${user.id || user.did}, Ïù¥Î¶Ñ: ${name}`);

    // ÏïîÌò∏Ìôî ÌÇ§ ÏÉùÏÑ± (Í∏∞Ï°¥ Í∏∞Îä•)
    let encryptionKey = null;
    if (isEncrypted) {
      encryptionKey = await cryptoService.generateVaultKey(user.id || did, name);
    }

    // Î≥ºÌä∏ Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ± (Í∏∞Ï°¥ + Ïã†Í∑ú ÌÜµÌï©)
    const vaultData = {
      id: uuidv4(),
      user_id: user.id,
      user_did: user.did || did,
      userDid: user.did || did, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      vault_name: name,
      name: name, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      description: description || `${name} Í∞úÏù∏ Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏`,
      vault_type: type,
      category: category || type, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      is_encrypted: isEncrypted,
      encrypted: isEncrypted, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      encryption_key_id: encryptionKey?.keyId || null,
      access_permissions: {
        owner: user.id || did,
        read: [user.id || did],
        write: [user.id || did],
        admin: [user.id || did]
      },
      compartment_count: 0,
      total_size: 0,
      dataSize: 0, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      metadata: {
        createdBy: user.username || 'unknown',
        platform: 'web',
        initialSize: 0,
        version: '1.0'
      },
      created_at: new Date().toISOString(),
      createdAt: new Date().toISOString(), // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      updated_at: new Date().toISOString(),
      updatedAt: new Date().toISOString(), // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      tags: [],
      accessCount: 0
    };

    // Î≥ºÌä∏ ÏÉùÏÑ± (Îëê Î∞©Ïãù Î™®Îëê ÏßÄÏõê)
    let vault;
    if (typeof db.createVault === 'function') {
      vault = await db.createVault(vaultData);
    } else {
      vault = await db.saveDataVault(vaultData);
    }

    console.log(`‚úÖ Î≥ºÌä∏ ÏÉùÏÑ± ÏôÑÎ£å - ID: ${vault.id}`);

    res.status(201).json({
      success: true,
      vault: {
        id: vault.id,
        name: vault.vault_name || vault.name,
        description: vault.description,
        type: vault.vault_type || vault.category,
        isEncrypted: vault.is_encrypted || vault.encrypted,
        createdAt: vault.created_at || vault.createdAt
      },
      message: 'Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Î≥ºÌä∏ ÏÉùÏÑ± Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to create vault',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üíæ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• (Í∏∞Ï°¥ Í∞úÏù∏ CUE Ï∂îÏ∂ú Í∏∞Îä• Ïú†ÏßÄ)
// POST /api/vault/save ÎòêÎäî POST /api/vault/:did
// ============================================================================

router.post(['/save', '/:did/data'], authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const { 
    vaultId, 
    data, 
    type = 'text', 
    source = 'manual',
    compress = true,
    extractCues = true,
    category = 'general'
  } = req.body;
  
  const user = (req as any).user;
  const did = req.params.did || user.did;

  if (!vaultId && !did) {
    return res.status(400).json({
      success: false,
      error: 'Vault ID or DID is required'
    });
  }

  if (!data) {
    return res.status(400).json({
      success: false,
      error: 'Data is required'
    });
  }

  try {
    console.log(`üíæ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏãúÏûë - Î≥ºÌä∏: ${vaultId || 'auto'}, ÌÉÄÏûÖ: ${type}`);

    // Î≥ºÌä∏ ÌôïÏù∏/ÏÉùÏÑ±
    let vault;
    if (vaultId) {
      // Í∏∞Ï°¥ Î∞©Ïãù: ÌäπÏ†ï Î≥ºÌä∏Ïóê Ï†ÄÏû•
      if (typeof db.getVault === 'function') {
        vault = await db.getVault(vaultId);
      } else {
        vault = await db.getDataVault(vaultId);
      }
      
      if (!vault || (vault.user_id !== user.id && vault.userDid !== did)) {
        return res.status(403).json({
          success: false,
          error: 'Access denied to vault'
        });
      }
    } else {
      // Ïã†Í∑ú Î∞©Ïãù: DID Í∏∞Î∞ò ÏûêÎèô Î≥ºÌä∏ ÏÑ†ÌÉù/ÏÉùÏÑ±
      const vaults = await db.getDataVaults(did);
      vault = vaults.find(v => v.category === category) || vaults[0];
      
      if (!vault) {
        // Í∏∞Î≥∏ Î≥ºÌä∏ ÏÉùÏÑ±
        const defaultVaultData = {
          id: uuidv4(),
          userDid: did,
          name: 'Default Vault',
          category: category,
          encrypted: true,
          dataSize: 0,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          accessCount: 0,
          tags: ['auto-created'],
          metadata: { source: 'auto', version: '1.0' }
        };
        vault = await db.saveDataVault(defaultVaultData);
      }
    }

    // Îç∞Ïù¥ÌÑ∞ ÏïïÏ∂ï (Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
    let processedData = data;
    let compressionInfo = null;
    
    if (compress && typeof data === 'string' && data.length > 100) {
      try {
        const compressed = await compressionService.compressContent(data);
        processedData = compressed.compressedContent;
        compressionInfo = {
          ratio: compressed.compressionRatio,
          preservation: compressed.semanticPreservation,
          keywords: compressed.keywords,
          entities: compressed.entities,
          topics: compressed.topics
        };
      } catch (compressionError) {
        console.warn('‚ö†Ô∏è ÏïïÏ∂ï Ïã§Ìå®, ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©:', compressionError);
      }
    }

    // Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî (Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
    let encryptedData = processedData;
    if (vault.is_encrypted || vault.encrypted) {
      try {
        encryptedData = await cryptoService.encryptVaultData(
          processedData, 
          vault.encryption_key_id
        );
      } catch (encryptionError) {
        console.warn('‚ö†Ô∏è ÏïîÌò∏Ìôî Ïã§Ìå®:', encryptionError);
      }
    }

    // Ïª¥ÌååÌä∏Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ± (Í∏∞Ï°¥ + Ïã†Í∑ú ÌÜµÌï©)
    const compartmentData = {
      id: uuidv4(),
      vault_id: vault.id,
      vaultId: vault.id, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      user_id: user.id,
      user_did: user.did || did,
      userDid: user.did || did, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      data_type: type,
      dataType: type, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      category: category,
      original_content: (vault.is_encrypted || vault.encrypted) ? null : data,
      encrypted_content: encryptedData,
      data: encryptedData, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      originalData: (vault.is_encrypted || vault.encrypted) ? null : data, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      is_encrypted: vault.is_encrypted || vault.encrypted,
      encrypted: vault.is_encrypted || vault.encrypted, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      compressed: !!compressionInfo,
      compression_info: compressionInfo,
      compression: compressionInfo, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      source_platform: source,
      source: source, // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      dataSize: typeof data === 'string' ? data.length : JSON.stringify(data).length,
      metadata: {
        originalSize: typeof data === 'string' ? data.length : JSON.stringify(data).length,
        compressedSize: typeof processedData === 'string' ? processedData.length : JSON.stringify(processedData).length,
        source: source,
        timestamp: Date.now(),
        contentType: type,
        version: '1.0'
      },
      tags: [type, source],
      accessCount: 0,
      created_at: new Date().toISOString(),
      createdAt: new Date().toISOString(), // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
      updated_at: new Date().toISOString(),
      updatedAt: new Date().toISOString() // Ïã†Í∑ú ÌòïÏãù Ìò∏Ìôò
    };

    // Ïª¥ÌååÌä∏Î®ºÌä∏ Ï†ÄÏû• (Îëê Î∞©Ïãù Î™®Îëê ÏßÄÏõê)
    let compartment;
    if (typeof db.createCompartment === 'function') {
      compartment = await db.createCompartment(compartmentData);
    } else {
      compartment = await db.saveDataVault(compartmentData);
    }

    // Personal CUE Ï∂îÏ∂ú (Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
    let extractedCues = [];
    if (extractCues && typeof data === 'string') {
      setImmediate(async () => {
        try {
          extractedCues = await cueExtractor.extractAndStoreCues(user.did || did, {
            content: data,
            type: type,
            source: source,
            vaultId: vault.id,
            compartmentId: compartment.id
          });
          
          console.log(`üß† CUE Ï∂îÏ∂ú ÏôÑÎ£å - ${extractedCues.length}Í∞ú Ï∂îÏ∂ú`);
          
          // CUE ÎßàÏù¥Îãù (Ïã†Í∑ú Í∏∞Îä•)
          try {
            const miningResult = await cueMinigService.mineFromDataVault(compartmentData);
            await db.updateCueBalance(user.did || did, miningResult.tokensEarned);
            console.log(`‚ö° CUE ÎßàÏù¥Îãù ÏôÑÎ£å: +${miningResult.tokensEarned} CUE`);
          } catch (miningError) {
            console.warn('‚ö†Ô∏è CUE ÎßàÏù¥Îãù Ïã§Ìå®:', miningError);
          }
        } catch (error) {
          console.error('‚ùå CUE Ï∂îÏ∂ú Ïò§Î•ò:', error);
        }
      });
    }

    // Î≥ºÌä∏ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Í∏∞Ï°¥ Í∏∞Îä•)
    if (typeof db.updateVaultStats === 'function') {
      await db.updateVaultStats(vault.id, {
        compartment_count: (vault.compartment_count || 0) + 1,
        total_size: (vault.total_size || 0) + compartmentData.metadata.originalSize,
        last_accessed_at: new Date().toISOString()
      });
    }

    console.log(`‚úÖ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å - Ïª¥ÌååÌä∏Î®ºÌä∏: ${compartment.id}`);

    res.json({
      success: true,
      compartment: {
        id: compartment.id,
        vaultId: vault.id,
        type: type,
        category: category,
        size: compartmentData.metadata.originalSize,
        compressed: !!compressionInfo,
        encrypted: vault.is_encrypted || vault.encrypted,
        createdAt: compartment.created_at || compartment.createdAt
      },
      vault: {
        id: vault.id,
        name: vault.vault_name || vault.name
      },
      compression: compressionInfo,
      cueExtraction: {
        started: extractCues,
        estimatedCount: extractCues ? Math.floor(data.length / 100) : 0
      },
      message: 'Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to save data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üìñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Í∏∞Ï°¥ + Ïã†Í∑ú Í∏∞Îä• ÌÜµÌï©)
// GET /api/vault/:vaultId/data ÎòêÎäî GET /api/vault/:did/:vaultId
// ============================================================================

router.get(['/:vaultId/data', '/:did/:vaultId'], authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const { vaultId, did } = req.params;
  const { limit = 20, offset = 0, type, includeData = 'true' } = req.query;
  const user = (req as any).user;

  try {
    console.log(`üìñ Î≥ºÌä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå - Î≥ºÌä∏: ${vaultId}`);

    // Î≥ºÌä∏ Í∂åÌïú ÌôïÏù∏ (Îëê Î∞©Ïãù Î™®Îëê ÏßÄÏõê)
    let vault;
    if (typeof db.getVault === 'function') {
      vault = await db.getVault(vaultId);
    } else {
      vault = await db.getDataVault(vaultId);
    }

    if (!vault) {
      return res.status(404).json({
        success: false,
        error: 'Vault not found'
      });
    }

    // Í∂åÌïú ÌôïÏù∏
    const hasAccess = vault.user_id === user.id || 
                     vault.userDid === (user.did || did) ||
                     vault.user_did === (user.did || did);

    if (!hasAccess) {
      return res.status(403).json({
        success: false,
        error: 'Access denied to vault'
      });
    }

    // Ïª¥ÌååÌä∏Î®ºÌä∏ Î™©Î°ù Ï°∞Ìöå (Í∏∞Ï°¥ Î∞©Ïãù)
    let compartments = [];
    if (typeof db.getVaultCompartments === 'function') {
      compartments = await db.getVaultCompartments(vaultId, {
        limit: parseInt(limit as string),
        offset: parseInt(offset as string),
        type: type as string
      });
    } else {
      // Ïã†Í∑ú Î∞©Ïãù: Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÌõÑ ÌïÑÌÑ∞ÎßÅ
      const allVaults = await db.getDataVaults(user.did || did);
      compartments = allVaults.filter(v => v.vaultId === vaultId || v.vault_id === vaultId);
      
      if (type) {
        compartments = compartments.filter(c => c.data_type === type || c.dataType === type);
      }
      
      const limitNum = parseInt(limit as string);
      const offsetNum = parseInt(offset as string);
      compartments = compartments.slice(offsetNum, offsetNum + limitNum);
    }

    // Îç∞Ïù¥ÌÑ∞ Î≥µÌò∏Ìôî (Í∏∞Ï°¥ Í∏∞Îä• Ïú†ÏßÄ)
    const decryptedCompartments = await Promise.all(
      compartments.map(async (compartment) => {
        let content = compartment.original_content || compartment.originalData;
        
        if ((vault.is_encrypted || vault.encrypted) && 
            (compartment.encrypted_content || compartment.data)) {
          try {
            content = await cryptoService.decryptVaultData(
              compartment.encrypted_content || compartment.data,
              vault.encryption_key_id
            );
          } catch (error) {
            console.warn('Î≥µÌò∏Ìôî Ïã§Ìå®:', error);
            content = '[ÏïîÌò∏ÌôîÎêú Îç∞Ïù¥ÌÑ∞]';
          }
        }

        return {
          id: compartment.id,
          type: compartment.data_type || compartment.dataType,
          category: compartment.category,
          content: includeData === 'true' ? content : undefined,
          source: compartment.source_platform || compartment.source,
          size: compartment.metadata?.originalSize || compartment.dataSize || 0,
          compressed: !!compartment.compression_info || compartment.compressed,
          encrypted: compartment.is_encrypted || compartment.encrypted,
          tags: compartment.tags || [],
          createdAt: compartment.created_at || compartment.createdAt,
          updatedAt: compartment.updated_at || compartment.updatedAt
        };
      })
    );

    // Ïï°ÏÑ∏Ïä§ Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä (Ïã†Í∑ú Í∏∞Îä•)
    if (typeof db.incrementVaultAccess === 'function') {
      await db.incrementVaultAccess(vaultId);
    }

    res.json({
      success: true,
      vault: {
        id: vault.id,
        name: vault.vault_name || vault.name,
        type: vault.vault_type || vault.category,
        isEncrypted: vault.is_encrypted || vault.encrypted
      },
      compartments: decryptedCompartments,
      pagination: {
        limit: parseInt(limit as string),
        offset: parseInt(offset as string),
        total: compartments.length,
        hasMore: compartments.length === parseInt(limit as string)
      },
      metadata: {
        lastAccessed: new Date().toISOString(),
        includeData: includeData === 'true'
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get vault data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üîç Í∞úÏù∏ CUE Ï°∞Ìöå Î∞è Í≤ÄÏÉâ (Í∏∞Ï°¥ + Ïã†Í∑ú Í∏∞Îä• ÌÜµÌï©)
// GET /api/vault/:vaultId/cues ÎòêÎäî GET /api/vault/:did/search
// ============================================================================

router.get(['/:vaultId/cues', '/:did/search'], authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const { vaultId, did } = req.params;
  const { limit = 50, category, query, tags, dateFrom, dateTo } = req.query;
  const user = (req as any).user;

  try {
    if (req.path.includes('/cues')) {
      // Í∏∞Ï°¥ Î∞©Ïãù: Í∞úÏù∏ CUE Ï°∞Ìöå
      console.log(`üîç Í∞úÏù∏ CUE Ï°∞Ìöå - Î≥ºÌä∏: ${vaultId}`);

      const vault = await db.getVault(vaultId);
      if (!vault || vault.user_id !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Access denied to vault'
        });
      }

      const cues = await db.getPersonalCues(vaultId, {
        limit: parseInt(limit as string),
        category: category as string
      });

      res.json({
        success: true,
        vault: {
          id: vault.id,
          name: vault.vault_name
        },
        cues: cues.map(cue => ({
          id: cue.id,
          type: cue.content_type,
          content: cue.compressed_content,
          keywords: cue.keywords,
          entities: cue.entities,
          topics: cue.topics,
          importance: cue.importance_score,
          cueValue: cue.cue_mining_value,
          createdAt: cue.created_at
        })),
        count: cues.length,
        timestamp: new Date().toISOString()
      });
    } else {
      // Ïã†Í∑ú Î∞©Ïãù: Î≥ºÌä∏ Í≤ÄÏÉâ
      console.log(`üîç Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ Í≤ÄÏÉâ: ${did}, ÏøºÎ¶¨: ${query}`);

      let vaults = await db.getDataVaults(did);
      
      // ÏÇ≠Ï†úÎêú Î≥ºÌä∏ Ï†úÏô∏
      vaults = vaults.filter(vault => !vault.deleted);

      // ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ
      if (query) {
        const searchTerm = query.toString().toLowerCase();
        vaults = vaults.filter(vault => 
          JSON.stringify(vault.data || vault.encrypted_content || '').toLowerCase().includes(searchTerm) ||
          (vault.vault_type || vault.category || '').toLowerCase().includes(searchTerm) ||
          (vault.tags && vault.tags.some((tag: string) => tag.toLowerCase().includes(searchTerm)))
        );
      }

      // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞
      if (category) {
        vaults = vaults.filter(vault => 
          (vault.vault_type || vault.category) === category
        );
      }

      // ÌÉúÍ∑∏ ÌïÑÌÑ∞
      if (tags) {
        const tagList = tags.toString().split(',');
        vaults = vaults.filter(vault => 
          vault.tags && tagList.some(tag => vault.tags.includes(tag.trim()))
        );
      }

      // ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞
      if (dateFrom || dateTo) {
        vaults = vaults.filter(vault => {
          const vaultDate = new Date(vault.created_at || vault.createdAt);
          const fromDate = dateFrom ? new Date(dateFrom.toString()) : new Date(0);
          const toDate = dateTo ? new Date(dateTo.toString()) : new Date();
          return vaultDate >= fromDate && vaultDate <= toDate;
        });
      }

      // Í≤∞Í≥º Ï†úÌïú
      const limitNum = parseInt(limit.toString());
      const limitedVaults = vaults.slice(0, limitNum);

      res.json({
        success: true,
        vaults: limitedVaults,
        total: vaults.length,
        showing: limitedVaults.length,
        query: {
          text: query,
          category,
          tags,
          dateFrom,
          dateTo,
          limit: limitNum
        },
        timestamp: new Date().toISOString()
      });
    }

  } catch (error) {
    console.error('‚ùå CUE Ï°∞Ìöå/Í≤ÄÏÉâ Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get CUEs or search vaults',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üóëÔ∏è Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú (Í∏∞Ï°¥ + Ïã†Í∑ú ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú Í∏∞Îä•)
// DELETE /api/vault/:vaultId/compartments/:compartmentId ÎòêÎäî 
// DELETE /api/vault/:did/:vaultId
// ============================================================================

router.delete(['/:vaultId/compartments/:compartmentId', '/:did/:vaultId'], authMiddleware, 
asyncHandler(async (req: Request, res: Response) => {
  const { vaultId, compartmentId, did } = req.params;
  const { permanent = 'false' } = req.query;
  const user = (req as any).user;

  try {
    if (compartmentId) {
      // Í∏∞Ï°¥ Î∞©Ïãù: Ïª¥ÌååÌä∏Î®ºÌä∏ ÏÇ≠Ï†ú
      console.log(`üóëÔ∏è Ïª¥ÌååÌä∏Î®ºÌä∏ ÏÇ≠Ï†ú - ${compartmentId}`);

      const vault = await db.getVault(vaultId);
      if (!vault || vault.user_id !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      await db.deleteCompartment(compartmentId);

      res.json({
        success: true,
        message: 'Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.',
        timestamp: new Date().toISOString()
      });
    } else {
      // Ïã†Í∑ú Î∞©Ïãù: Î≥ºÌä∏ ÏÇ≠Ï†ú
      console.log(`üóëÔ∏è Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ ÏÇ≠Ï†ú: ${vaultId}, ÏòÅÍµ¨ÏÇ≠Ï†ú: ${permanent}`);

      const vault = await db.getDataVault(vaultId);
      
      if (!vault) {
        return res.status(404).json({
          success: false,
          error: 'Vault not found'
        });
      }

      // Í∂åÌïú ÌôïÏù∏
      if (vault.userDid !== (user.did || did)) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      if (permanent === 'true') {
        // ÏòÅÍµ¨ ÏÇ≠Ï†ú
        await db.deleteDataVault(vaultId);
        res.json({
          success: true,
          message: 'Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏Í∞Ä ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.',
          timestamp: new Date().toISOString()
        });
      } else {
        // ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú
        const deletedVault = await db.updateDataVault(vaultId, {
          ...vault,
          deleted: true,
          deletedAt: new Date().toISOString()
        });
        
        res.json({
          success: true,
          vault: deletedVault,
          message: 'Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§. (Î≥µÍµ¨ Í∞ÄÎä•)',
          timestamp: new Date().toISOString()
        });
      }
    }

  } catch (error) {
    console.error('‚ùå Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to delete data',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üìä Î≥ºÌä∏ ÌÜµÍ≥Ñ (Í∏∞Ï°¥ + Ïã†Í∑ú Í≥†Í∏â ÌÜµÍ≥Ñ)
// GET /api/vault/:vaultId/stats ÎòêÎäî GET /api/vault/:did/stats
// ============================================================================

router.get(['/:vaultId/stats', '/:did/stats'], authMiddleware, asyncHandler(async (req: Request, res: Response) => {
  const { vaultId, did } = req.params;
  const user = (req as any).user;

  try {
    if (vaultId && !did) {
      // Í∏∞Ï°¥ Î∞©Ïãù: ÌäπÏ†ï Î≥ºÌä∏ ÌÜµÍ≥Ñ
      console.log(`üìä Î≥ºÌä∏ ÌÜµÍ≥Ñ Ï°∞Ìöå - ${vaultId}`);

      const vault = await db.getVault(vaultId);
      if (!vault || vault.user_id !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      const stats = await db.getVaultStats(vaultId);

      res.json({
        success: true,
        vault: {
          id: vault.id,
          name: vault.vault_name
        },
        stats: {
          totalCompartments: stats.compartmentCount,
          totalSize: stats.totalSize,
          dataTypes: stats.dataTypes,
          compressionRatio: stats.averageCompression,
          cueCount: stats.personalCueCount,
          lastActivity: stats.lastActivity
        },
        timestamp: new Date().toISOString()
      });
    } else {
      // Ïã†Í∑ú Î∞©Ïãù: Ï†ÑÏ≤¥ Î≥ºÌä∏ ÌÜµÍ≥Ñ
      console.log(`üìä Îç∞Ïù¥ÌÑ∞ Î≥ºÌä∏ ÌÜµÍ≥Ñ: ${did}`);

      const vaults = await db.getDataVaults(did);
      const activeVaults = vaults.filter(vault => !vault.deleted);

      const stats = {
        total: activeVaults.length,
        totalSize: activeVaults.reduce((sum, v) => sum + (v.dataSize || 0), 0),
        categories: activeVaults.reduce((acc: any, vault) => {
          const category = vault.vault_type || vault.category;
          acc[category] = (acc[category] || 0) + 1;
          return acc;
        }, {}),
        compression: {
          compressed: activeVaults.filter(v => v.compressed).length,
          totalOriginalSize: activeVaults.reduce((sum, v) => 
            sum + (v.originalData ? JSON.stringify(v.originalData).length : v.dataSize), 0),
          totalCompressedSize: activeVaults.reduce((sum, v) => sum + (v.dataSize || 0), 0)
        },
        encryption: {
          encrypted: activeVaults.filter(v => v.is_encrypted || v.encrypted).length,
          unencrypted: activeVaults.filter(v => !(v.is_encrypted || v.encrypted)).length
        },
        activity: {
          recentlyCreated: activeVaults.filter(v => 
            new Date(v.created_at || v.createdAt) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          ).length,
          recentlyUpdated: activeVaults.filter(v => 
            new Date(v.updated_at || v.updatedAt) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          ).length
        }
      };

      res.json({
        success: true,
        stats,
        timestamp: new Date().toISOString()
      });
    }

  } catch (error) {
    console.error('‚ùå Î≥ºÌä∏ ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get vault stats',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}));

// ============================================================================
// üìã ÏÉÅÌÉú ÌôïÏù∏ API
// GET /api/vault/health
// ============================================================================

router.get('/health', (req, res) => {
  res.json({
    success: true,
    service: 'Integrated Vault Routes',
    database: db.constructor.name,
    timestamp: new Date().toISOString(),
    features: [
      'Personal data vaults',
      'Encryption & compression',
      'Personal CUE extraction',
      'CUE token mining',
      'Advanced search',
      'Statistics & analytics',
      'Soft delete',
      'Compartment management'
    ],
    compatibility: {
      legacy: 'Supports existing getUserVaults, createVault APIs',
      modern: 'Supports new getDataVaults, saveDataVault APIs'
    }
  });
});

console.log('‚úÖ Integrated Vault routes loaded successfully');

export default router;