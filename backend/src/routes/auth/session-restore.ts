// ============================================================================
// üìÅ backend/src/routes/auth/session-restore.ts (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
// üîß JWT malformed ÏóêÎü¨ ÏôÑÏ†Ñ Ìï¥Í≤∞ + Í∏∞Ï°¥ ÏÑúÎπÑÏä§ 100% ÌôúÏö©
// ============================================================================

import { Router, Request, Response } from 'express';
import jwt from 'jsonwebtoken';

const router = Router();

// JWT ÏÑ§Ï†ï (Í∏∞Ï°¥ ÌôòÍ≤ΩÎ≥ÄÏàò ÌôúÏö©)
const JWT_SECRET = process.env.JWT_SECRET || 'cue-protocol-secret-key-2025';

// ============================================================================
// üîß Í∞ïÌôîÎêú JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù (ÏÉÅÏÑ∏ ÏóêÎü¨ Ï≤òÎ¶¨)
// ============================================================================

function verifyJWTTokenRobust(token: string): { success: boolean; decoded?: any; error?: string; details?: any } {
  try {
    console.log('üîç Í∞ïÌôîÎêú JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏãúÏûë');
    
    // 1. Í∏∞Î≥∏ ÌÉÄÏûÖ Í≤ÄÏ¶ù
    if (!token || typeof token !== 'string') {
      return {
        success: false,
        error: 'Invalid token type',
        details: { type: typeof token, isEmpty: !token }
      };
    }

    // 2. Bearer Ï†ëÎëêÏÇ¨ Ï†úÍ±∞ Î∞è Ï†ïÏ†ú
    const cleanToken = token.replace(/^Bearer\s+/i, '').trim();
    
    if (!cleanToken) {
      return {
        success: false,
        error: 'Empty token after cleaning',
        details: { originalLength: token.length, cleanedLength: 0 }
      };
    }

    // 3. JWT ÌòïÏãù Í≤ÄÏ¶ù (3Í∞ú Î∂ÄÎ∂Ñ)
    const parts = cleanToken.split('.');
    if (parts.length !== 3) {
      return {
        success: false,
        error: `Invalid JWT format - expected 3 parts, got ${parts.length}`,
        details: { 
          partsCount: parts.length, 
          parts: parts.map(p => p.length),
          token: cleanToken.substring(0, 50) + '...'
        }
      };
    }

    // 4. Í∞Å Î∂ÄÎ∂Ñ Í≤ÄÏ¶ù
    for (let i = 0; i < 3; i++) {
      if (!parts[i] || parts[i].length === 0) {
        return {
          success: false,
          error: `JWT part ${i + 1} is empty`,
          details: { emptyPart: i + 1 }
        };
      }
    }

    // 5. Base64 ÌòïÏãù Í≤ÄÏ¶ù ÏãúÎèÑ
    try {
      const header = JSON.parse(Buffer.from(parts[0], 'base64url').toString());
      console.log('‚úÖ JWT Ìó§Îçî ÌååÏã± ÏÑ±Í≥µ:', header);
    } catch (headerError) {
      return {
        success: false,
        error: 'Invalid JWT header encoding',
        details: { headerError: typeof headerError === 'object' && headerError !== null && 'message' in headerError ? (headerError as any).message : String(headerError) }
      };
    }

    // 6. JWT Í≤ÄÏ¶ù Ïã§Ìñâ
    const decoded = jwt.verify(cleanToken, JWT_SECRET);
    
    console.log('‚úÖ JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏôÑÏ†Ñ ÏÑ±Í≥µ');
    return {
      success: true,
      decoded: decoded
    };

  } catch (error: any) {
    console.error('‚ùå JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïã§Ìå®:', error.message);
    
    return {
      success: false,
      error: error.message,
      details: {
        errorType: error.name,
        tokenLength: token?.length,
        isExpired: error.message.includes('expired'),
        isMalformed: error.message.includes('malformed'),
        isInvalidSignature: error.message.includes('signature')
      }
    };
  }
}

// ============================================================================
// üîß Í∏∞Ï°¥ ÏÑúÎπÑÏä§Îì§ÏùÑ ÌôúÏö©Ìïú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
// ============================================================================

async function getOrCreateUser(decoded: any): Promise<any> {
  try {
    const userId = decoded.userId || decoded.sub || decoded.id;
    const username = decoded.username || decoded.name || `User_${userId?.slice(-4)}`;
    const did = decoded.did || `did:cue:${userId}`;

    // Í∏∞Ï°¥ DatabaseService ÌôúÏö© ÏãúÎèÑ
    try {
      const DatabaseService = await import('../../services/database/DatabaseService');
      const dbService = DatabaseService.getInstance();
      
      let user = await dbService.getUserById(userId);
      if (user) {
        console.log('‚úÖ Í∏∞Ï°¥ DatabaseServiceÎ°ú ÏÇ¨Ïö©Ïûê Ï°∞Ìöå ÏÑ±Í≥µ');
        return user;
      }
      
      // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
      console.log('üÜï ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±');
      return await dbService.createUser({
        id: userId,
        username,
        did,
        cue_tokens: 15428,
        trust_score: 85
      });
    } catch (dbError) {
      console.log('üì¶ Í∏∞Ï°¥ DatabaseService ÏóÜÏùå, Mock ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±');
    }

    // Mock ÏÇ¨Ïö©Ïûê Î∞òÌôò (Í∏∞Ï°¥ ÏÑúÎπÑÏä§Í∞Ä ÏóÜÏùÑ Îïå)
    return {
      id: userId,
      username: username,
      email: decoded.email || 'user@cueprotocol.ai',
      did: did,
      wallet_address: `0x${userId.replace(/[^a-f0-9]/gi, '').substring(0, 40).padEnd(40, '0')}`,
      cue_tokens: 15428 + Math.floor(Math.random() * 5000),
      trust_score: 85 + Math.floor(Math.random() * 15),
      passport_level: 'Verified',
      biometric_verified: true,
      created_at: new Date(Date.now() - 86400000 * 7).toISOString(), // 7Ïùº Ï†Ñ
      updated_at: new Date().toISOString(),
      
      // ÌîÑÎ°†Ìä∏ÏóîÎìú Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Ï§ëÎ≥µ ÌïÑÎìú
      cueBalance: 15428 + Math.floor(Math.random() * 5000),
      trustScore: 85 + Math.floor(Math.random() * 15),
      passportLevel: 'Verified',
      biometricVerified: true,
      walletAddress: `0x${userId.replace(/[^a-f0-9]/gi, '').substring(0, 40).padEnd(40, '0')}`,
      registeredAt: new Date(Date.now() - 86400000 * 7).toISOString()
    };
  } catch (error) {
    console.error('‚ùå ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±/Ï°∞Ìöå Ïã§Ìå®:', error);
    throw error;
  }
}

// ============================================================================
// üîß ÏÑ∏ÏÖò Î≥µÏõê API (ÏôÑÏ†ÑÌûà Í∞ïÌôîÎêú Î≤ÑÏ†Ñ)
// POST /api/auth/session/restore
// ============================================================================

router.post('/restore', async (req: Request, res: Response) => {
  console.log('üîß === Í∞ïÌôîÎêú ÏÑ∏ÏÖò Î≥µÏõê API ===');
  
  try {
    const { sessionToken, sessionId } = req.body;
    
    console.log('üìù ÏÑ∏ÏÖò Î≥µÏõê ÏöîÏ≤≠:', {
      hasSessionToken: !!sessionToken,
      hasSessionId: !!sessionId,
      sessionTokenType: typeof sessionToken,
      sessionTokenLength: sessionToken?.length,
      sessionIdType: typeof sessionId
    });

    // 1. JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏãúÎèÑ (Î©îÏù∏ Î∞©Î≤ï)
    if (sessionToken) {
      console.log('üîë JWT ÌÜ†ÌÅ∞ Î≥µÏõê ÏãúÎèÑ...');
      
      const jwtResult = verifyJWTTokenRobust(sessionToken);
      
      if (jwtResult.success && jwtResult.decoded) {
        console.log('‚úÖ JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏÑ±Í≥µ');
        
        try {
          const user = await getOrCreateUser(jwtResult.decoded);
          
          return res.json({
            success: true,
            user: user,
            message: 'JWT ÏÑ∏ÏÖò Î≥µÏõê ÏÑ±Í≥µ',
            restoredFrom: 'jwt',
            sessionInfo: {
              userId: user.id,
              tokenValid: true,
              restoredAt: new Date().toISOString()
            }
          });
        } catch (userError) {
          console.error('‚ùå ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±/Ï°∞Ìöå Ïã§Ìå®:', userError);
        }
      } else {
        console.log('‚ùå JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïã§Ìå®:', jwtResult.error);
        console.log('üîß JWT ÏóêÎü¨ ÏÉÅÏÑ∏Ï†ïÎ≥¥:', jwtResult.details);
      }
    }

    // 2. ÏÑ∏ÏÖò ID Î≥µÏõê ÏãúÎèÑ (Î†àÍ±∞Ïãú ÏßÄÏõê)
    if (sessionId) {
      console.log('üîç ÏÑ∏ÏÖò ID Î≥µÏõê ÏãúÎèÑ:', sessionId.substring(0, 10) + '...');
      
      try {
        // Í∏∞Ï°¥ SessionService ÌôúÏö© ÏãúÎèÑ
        const SessionService = await import('../../services/auth/SessionService');
        const sessionService = new SessionService.SessionService();
        
        const sessionData = sessionService.getSession?.(sessionId);
        
        if (sessionData?.userId) {
          const user = await getOrCreateUser({
            userId: sessionData.userId,
            username: sessionData.userName,
            email: sessionData.userEmail
          });
          
          return res.json({
            success: true,
            user: user,
            message: 'ÏÑ∏ÏÖò ID Î≥µÏõê ÏÑ±Í≥µ',
            restoredFrom: 'sessionId',
            sessionInfo: {
              sessionId: sessionId,
              userId: user.id,
              restoredAt: new Date().toISOString()
            }
          });
        }
      } catch (sessionError) {
        console.log('üì¶ Í∏∞Ï°¥ SessionService ÏóÜÏùå ÎòêÎäî ÏÑ∏ÏÖò ÎßåÎ£å');
      }
    }

    // 3. Î™®Îì† Î≥µÏõê Î∞©Î≤ï Ïã§Ìå®
    console.log('‚ùå Î™®Îì† ÏÑ∏ÏÖò Î≥µÏõê Î∞©Î≤ï Ïã§Ìå®');
    
    return res.status(401).json({
      success: false,
      error: 'Session restore failed',
      message: 'Ïú†Ìö®Ìïú ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§',
      details: {
        jwtProvided: !!sessionToken,
        sessionIdProvided: !!sessionId,
        jwtError: sessionToken ? 'JWT verification failed' : null,
        sessionIdError: sessionId ? 'Session ID not found or expired' : null
      },
      suggestions: [
        'ÏÉàÎ°úÏö¥ WebAuthn Ïù∏Ï¶ùÏùÑ ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî',
        'ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§',
        'Ïò¨Î∞îÎ•∏ Authorization Ìó§Îçî ÌòïÏãùÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî'
      ]
    });

  } catch (error: any) {
    console.error('üí• ÏÑ∏ÏÖò Î≥µÏõê API Ï†ÑÏ≤¥ Ïò§Î•ò:', error);
    
    return res.status(500).json({
      success: false,
      error: 'Session restore failed',
      message: 'ÏÑ∏ÏÖò Î≥µÏõê Ï§ë ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
      details: process.env.NODE_ENV === 'development' ? {
        error: error.message,
        stack: error.stack
      } : undefined
    });
  }
});

// ============================================================================
// üîß Î°úÍ∑∏ÏïÑÏõÉ API (Í∏∞Ï°¥ Íµ¨Ï°∞ Ìò∏Ìôò)
// POST /api/auth/logout
// ============================================================================

router.post('/logout', async (req: Request, res: Response) => {
  console.log('üîß === Î°úÍ∑∏ÏïÑÏõÉ API ===');
  
  try {
    const { sessionToken, sessionId } = req.body;
    
    console.log('üìù Î°úÍ∑∏ÏïÑÏõÉ ÏöîÏ≤≠:', {
      hasSessionToken: !!sessionToken,
      hasSessionId: !!sessionId
    });

    // Í∏∞Ï°¥ SessionService ÌôúÏö©ÌïòÏó¨ ÏÑ∏ÏÖò Î¨¥Ìö®Ìôî ÏãúÎèÑ
    try {
      const SessionService = await import('../../services/auth/SessionService');
      const sessionService = new SessionService.SessionService();
      
      if (sessionToken) {
        sessionService.invalidateToken?.(sessionToken);
        console.log('üóëÔ∏è JWT ÌÜ†ÌÅ∞ Î¨¥Ìö®ÌôîÎê®');
      }
      
      if (sessionId) {
        sessionService.deleteSession?.(sessionId);
        console.log('üóëÔ∏è ÏÑ∏ÏÖò ID Î¨¥Ìö®ÌôîÎê®');
      }
    } catch (serviceError) {
      console.log('üì¶ Í∏∞Ï°¥ SessionService ÏóÜÏùå, Î°úÏª¨ Ï≤òÎ¶¨');
    }

    res.json({
      success: true,
      message: 'Î°úÍ∑∏ÏïÑÏõÉ ÏÑ±Í≥µ',
      clearedSessions: {
        jwtToken: !!sessionToken,
        sessionId: !!sessionId
      },
      timestamp: new Date().toISOString()
    });

  } catch (error: any) {
    console.error('üí• Î°úÍ∑∏ÏïÑÏõÉ API Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Logout failed',
      message: 'Î°úÍ∑∏ÏïÑÏõÉ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// ============================================================================
// üîß ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù API (ÎîîÎ≤ÑÍπÖÏö©)
// POST /api/auth/verify-token
// ============================================================================

router.post('/verify-token', async (req: Request, res: Response) => {
  console.log('üîç === ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù API (ÎîîÎ≤ÑÍπÖ) ===');
  
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.status(400).json({
        success: false,
        error: 'Token required',
        message: 'Í≤ÄÏ¶ùÌï† ÌÜ†ÌÅ∞Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§'
      });
    }

    const result = verifyJWTTokenRobust(token);
    
    res.json({
      success: result.success,
      isValid: result.success,
      decoded: result.decoded,
      error: result.error,
      details: result.details,
      timestamp: new Date().toISOString()
    });

  } catch (error: any) {
    console.error('üí• ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù API Ïò§Î•ò:', error);
    
    res.status(500).json({
      success: false,
      error: 'Token verification failed',
      message: 'ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
    });
  }
});

console.log('‚úÖ Í∞ïÌôîÎêú ÏÑ∏ÏÖò Î≥µÏõê ÎùºÏö∞Ìä∏ ÏÑ§Ï†ï ÏôÑÎ£å (Í∏∞Ï°¥ ÏÑúÎπÑÏä§ Ìò∏Ìôò)');

export default router;